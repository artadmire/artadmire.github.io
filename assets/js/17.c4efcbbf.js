(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{632:function(t,a,e){t.exports=e.p+"assets/img/auto.1858b074.png"},633:function(t,a,e){t.exports=e.p+"assets/img/badge.78fb9fb6.png"},634:function(t,a,e){t.exports=e.p+"assets/img/luky.2e5d912f.png"},635:function(t,a,e){t.exports=e.p+"assets/img/luky1.02ccdc4d.png"},708:function(t,a,e){"use strict";e.r(a);var s=e(13),r=Object(s.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("组件设计")]),t._v(" "),s("h1",{attrs:{id:"设计原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设计原则"}},[t._v("#")]),t._v(" 设计原则")]),t._v(" "),s("h2",{attrs:{id:"有意义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#有意义"}},[t._v("#")]),t._v(" 有意义")]),t._v(" "),s("ul",[s("li",[t._v("命名准确，充分表意。")]),t._v(" "),s("li",[t._v("参数准确，必要的类型检查。")]),t._v(" "),s("li",[t._v("适当的注释。")])]),t._v(" "),s("h2",{attrs:{id:"细粒度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#细粒度"}},[t._v("#")]),t._v(" 细粒度")]),t._v(" "),s("p",[s("strong",[t._v("一个组件只完成一个功能。")])]),t._v(" "),s("p",[t._v("在设计模式中，追求单一职责原则，在组件库的开发中同样适用。我们原则上一个组件只专注一件事情，单一职责的组件的好处很明显,由于职责单一就可以最大可能性地复用组件，但是这也带来一个问题，过度单一职责的组件也可能会导致过度抽象，造成组件库的碎片化。")]),t._v(" "),s("p",[t._v("举个例子，一个自动完成组件(AutoComplete),他其实是由 Input 组件和 Select 组件组合而成的,因此我们完全可以复用之前的相关组件,就比如 Antd 的AutoComplete组件中就复用了Select组件,同时Calendar、 Form 等等一系列组件都复用了 Select 组件,那么Select 的细粒度就是合适的,因为 Select 保持的这种细粒度很容易被复用.")]),t._v(" "),s("p",[s("img",{attrs:{src:e(632),alt:"auto"}})]),t._v(" "),s("p",[t._v("那么还有一个例子,一个徽章数组件(Badge),它的右上角会有红点提示,可能是数字也可能是 icon,他的职责当然也很单一，这个红点提示也理所当然也可以被单独抽象为一个独立组件,但是我们通常不会将他作为独立组件,因为在其他场景中这个组件是无法被复用的，因为没有类似的场景再需要小红点这个小组件了，所以作为独立组件就属于细粒度过小,因此我们往往将它作为 Badge 的内部组件,比如在 Antd 中它以ScrollNumber的名称作为Badge的内部组件存在。")]),t._v(" "),s("p",[s("img",{attrs:{src:e(633),alt:"badge"}})]),t._v(" "),s("p",[t._v("所以，所谓的单一职责组件要建立在可复用的基础上，对于不可复用的单一职责组件我们仅仅作为独立组件的内部组件即可。")]),t._v(" "),s("h2",{attrs:{id:"通用性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#通用性"}},[t._v("#")]),t._v(" 通用性")]),t._v(" "),s("p",[t._v("我们要设计的本身就是通用组件库,不同于我们常见的业务组件,通用组件是与业务解耦但是又服务于业务开发的,那么问题来了,如何保证组件的通用性,通用性高一定是好事吗?")]),t._v(" "),s("p",[t._v("比如我们设计一个选择器(Select)组件,通常我们会设计成这样.")]),t._v(" "),s("p",[s("img",{attrs:{src:e(634),alt:"luky"}})]),t._v(" "),s("p",[t._v("这是一个我们最常见也最常用的选择器,但是问题是其通用性大打折扣.")]),t._v(" "),s("p",[t._v("当我们有一个需求是长这样的时候,我们之前的选择器组件就不符合要求了,因为这个 Select 组件的最下部需\n要有一个可拓展的条目的按钮.")]),t._v(" "),s("p",[s("img",{attrs:{src:e(635),alt:"luky1"}})]),t._v(" "),s("p",[t._v("这个时候我们难道要重新修改之前的选择器组件,甚至再造一个符合要求的选择器组件吗?一旦有这种情况发生,那么只能说明之前的选择器组件通用性不够,需要我们重新设计。")]),t._v(" "),s("p",[t._v("Antd 的 Select 组件预留了dropdownRender来进行自定义渲染。")]),t._v(" "),s("p",[t._v("当然类似的设计还有很多,通用性设计其实是一定意义上放弃对 DOM 的掌控,而将 DOM 结构的决定权转移给开发者。")]),t._v(" "),s("h2",{attrs:{id:"容易测试"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#容易测试"}},[t._v("#")]),t._v(" 容易测试")]),t._v(" "),s("p",[t._v("更容易的单元测试覆盖。")]),t._v(" "),s("h2",{attrs:{id:"无状态-无副作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#无状态-无副作用"}},[t._v("#")]),t._v(" 无状态，无副作用")]),t._v(" "),s("ul",[s("li",[t._v("状态向上层提取，尽量少用内部状态。")]),t._v(" "),s("li",[t._v("解耦IO操作。")])])])}),[],!1,null,null,null);a.default=r.exports}}]);