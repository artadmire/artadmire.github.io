(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{629:function(t,a,_){t.exports=_.p+"assets/img/iframe.05e7de5d.png"},630:function(t,a,_){t.exports=_.p+"assets/img/wec.a5f77484.png"},631:function(t,a,_){t.exports=_.p+"assets/img/liucheng.a50065e4.png"},705:function(t,a,_){"use strict";_.r(a);var e=_(13),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"微前端"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#微前端"}},[t._v("#")]),t._v(" 微前端")]),t._v(" "),e("p",[t._v("微前端最早于2016年在Micro-Frontends被提出，并建⽴了早期的微前端模型。")]),t._v(" "),e("h2",{attrs:{id:"微前端是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#微前端是什么"}},[t._v("#")]),t._v(" 微前端是什么?")]),t._v(" "),e("p",[t._v("⼀种类似于微服务的架构，是⼀种由独⽴交付的多个前端应⽤组成整体的架构⻛格，将前端 应⽤分解成⼀些更⼩、更简单的能够独⽴开发、测试、部署的应⽤，⽽在⽤户看来仍然是内聚 的单个产品。")]),t._v(" "),e("h2",{attrs:{id:"为什么需要微前端"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要微前端"}},[t._v("#")]),t._v(" 为什么需要微前端")]),t._v(" "),e("p",[t._v("前端代码越来越重")]),t._v(" "),e("ul",[e("li",[t._v("几个 G 的前端代码库")]),t._v(" "),e("li",[t._v("数百号前端开发人员")]),t._v(" "),e("li",[t._v("几 MB 的 Bundle Size")])]),t._v(" "),e("p",[t._v("也越来越复杂")]),t._v(" "),e("ul",[e("li",[t._v("层出不穷的框架、类库")]),t._v(" "),e("li",[t._v("各式各样的工程化体系")]),t._v(" "),e("li",[t._v("别具特色的跨端实践")])]),t._v(" "),e("p",[t._v("从开发者和用户的角度来看：")]),t._v(" "),e("ul",[e("li",[t._v("DX(developer experience)\n"),e("ol",[e("li",[t._v("多个系统在⼀个仓库应⽤中，不同⼦应⽤独⽴SPA模式（路由是由前端实现的）")]),t._v(" "),e("li",[t._v("系统分为多个仓库，独⽴上线部署，采⽤MPA(多页面应用)模式（所有的路由都是由服务端实现的）")])])]),t._v(" "),e("li",[t._v("UX(user experience)\n"),e("ol",[e("li",[t._v("性能体验")]),t._v(" "),e("li",[t._v("⻚⾯跳转和⽤户体验问题")])])])]),t._v(" "),e("p",[t._v("因而需要一种分解复杂度、提升协作效率、支持灵活扩展的架构模式，于是，微前端登上了舞台。")]),t._v(" "),e("h2",{attrs:{id:"微前端解决了什么问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#微前端解决了什么问题"}},[t._v("#")]),t._v(" 微前端解决了什么问题？")]),t._v(" "),e("ul",[e("li",[t._v("业务模块间日益加剧的耦合如何治理？")]),t._v(" "),e("li",[t._v("开发团队如何拆分、解耦，才能达到并行开发的目的？")]),t._v(" "),e("li",[t._v("新框架、新方案如何适应现有的工程环境（构建工具等）？")]),t._v(" "),e("li",[t._v("旧的框架类库如何平稳升级？实现了不限技术栈")])]),t._v(" "),e("h2",{attrs:{id:"微前端应该具备的能力"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#微前端应该具备的能力"}},[t._v("#")]),t._v(" 微前端应该具备的能力")]),t._v(" "),e("ul",[e("li",[t._v("多个子应用并行")]),t._v(" "),e("li",[t._v("js沙箱")]),t._v(" "),e("li",[t._v("css隔离")]),t._v(" "),e("li",[t._v("父子应用通信")]),t._v(" "),e("li",[t._v("公共依赖加载")]),t._v(" "),e("li",[t._v("按需加载")]),t._v(" "),e("li",[t._v("预加载")])]),t._v(" "),e("h2",{attrs:{id:"如何实现微前端架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何实现微前端架构"}},[t._v("#")]),t._v(" 如何实现微前端架构")]),t._v(" "),e("p",[t._v("实现微前端，有几个思路，从构建的角度来看有两种，编译时构建微前端和运行时构建微前端：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("**编译时微前端，**通常将第三方库中的组件作为包，在构建时引入依赖。这种实现引入新的微前端需要重新编译，不够灵活。编译时的微前端可以通过Web Components，Monorepo等方式来实现。其中Monorepo非常流行，常见的工具有nx，rush，lerna等。")])]),t._v(" "),e("li",[e("p",[t._v("**运行时微前端，**是一次加载或通过延迟加载按需动态将微型前端注入到容器应用程序中时。当引入新的微前端的时候，不需要构建，可以动态在代码中定义加载。我眼中的微前端更多是指这种运行时加载的微前端，因为独立构建，部署和测试是我们对于“微”的定义。")])])]),t._v(" "),e("h2",{attrs:{id:"一些可以实现微前端的方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一些可以实现微前端的方案"}},[t._v("#")]),t._v(" 一些可以实现微前端的方案")]),t._v(" "),e("h3",{attrs:{id:"路由"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#路由"}},[t._v("#")]),t._v(" 路由")]),t._v(" "),e("p",[t._v("使⽤ HTTP 服务器的路由来重定向多个应⽤，MPA模式。")]),t._v(" "),e("h3",{attrs:{id:"emp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#emp"}},[t._v("#")]),t._v(" EMP")]),t._v(" "),e("p",[t._v("微前端之构建时⽅案(Module Federation EMP)。深入了解移步"),e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/295224710",target:"_blank",rel:"noopener noreferrer"}},[t._v("EMP微前端-带你快速入门！"),e("OutboundLink")],1)]),t._v(" "),e("h3",{attrs:{id:"iframe"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#iframe"}},[t._v("#")]),t._v(" iframe")]),t._v(" "),e("p",[t._v("页面里面嵌套一个iframe，通过设置url 来做微应用的划分，这样可以保证了每一个微应用 都是独立部署，独立运行的，哪一个就算出现了问题，也不会影响到其它的应用，可以保证在一定范围内用户正常使用。")]),t._v(" "),e("p",[e("img",{attrs:{src:_(629),alt:"iframe"}})]),t._v(" "),e("p",[t._v("存在的问题：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("URL 不同步。")])])]),t._v(" "),e("p",[t._v("浏览器刷新之后 iframe url 状态丢失，后退或者前进按钮无法使用。")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("UI 不同步，DOM 结构不共享。")])])]),t._v(" "),e("p",[t._v("这个问题目前已经遇到过了，想象一下 iframe 里来一个带遮罩层的弹出窗口，同时要求这个弹窗要在浏览器里居中显示，还要在浏览器 resize 的时候自动调整。")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("全局上下文完全隔离，内存变量不共享。")])])]),t._v(" "),e("p",[t._v("iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到不同域下的子应用中实现免登录效果。")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("在面对复杂业务场景下的性能表现不够好。")])])]),t._v(" "),e("p",[t._v("一方面，以 iframe 驱动的子应用每次挂载和卸载都是一次浏览器上下文重建、资源重新加载的过程；另一方面，iframe 会共享父应用的 http 连接数，也会对性能造成影响。少则 3 ～ 5s，如果页面本身性能就不是很好，有大量的公共资源或者需要预执行的业务逻辑，渲染时间有可能到 10s 以上。")]),t._v(" "),e("p",[t._v("#为什么不是")]),t._v(" "),e("h3",{attrs:{id:"web-components"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#web-components"}},[t._v("#")]),t._v(" Web Components")]),t._v(" "),e("p",[t._v("如果忘记了什么是Web Components，移步这里"),e("a",{attrs:{href:"https://artadmire.github.io/pages/project/web-components.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Web Components"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("img",{attrs:{src:_(630),alt:"web"}})]),t._v(" "),e("p",[t._v("https://github.com/ionic-team/stencil")]),t._v(" "),e("h2",{attrs:{id:"主流的微前端框架"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主流的微前端框架"}},[t._v("#")]),t._v(" 主流的微前端框架")]),t._v(" "),e("ul",[e("li",[t._v("single-spa：社区公认的主流⽅案，可以基于它做⼆次开发 。")]),t._v(" "),e("li",[t._v("qiankun：基于 single-spa 封装，增加 umi 特⾊，增加沙箱机制（JS、ShadowDOM 等） 阿里造的。")]),t._v(" "),e("li",[t._v("icestark：类似于 single-spa 实现，React 技术栈友好，阿⾥造的。")])]),t._v(" "),e("h2",{attrs:{id:"流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#流程"}},[t._v("#")]),t._v(" 流程")]),t._v(" "),e("p",[e("img",{attrs:{src:_(631),alt:"流程"}})])])}),[],!1,null,null,null);a.default=v.exports}}]);