(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{723:function(e,t,r){"use strict";r.r(t);var l=r(13),n=Object(l.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("ol",[r("li",[e._v("Vue中 Runtime + Compiler 和 Runtime-only 两种模式含义和区别")])]),e._v(" "),r("ul",[r("li",[e._v("runtime-only 比 runtime-compiler 轻 6kb，代码量更少")]),e._v(" "),r("li",[e._v("runtime-only 运行更快，性能更好")]),e._v(" "),r("li",[e._v("runtime-only 其实只能识别render函数，不能识别template，.vue 文件中的template也是被vue-template-compiler 翻译成了render函数，所以只能在.vue里写 template")]),e._v(" "),r("li",[e._v("Runtime + Compiler可以识别template方式写代码")])]),e._v(" "),r("p",[e._v("两者的编译流程：")]),e._v(" "),r("ul",[r("li",[e._v("runtime-only render  -> vdome -> 真实dom")]),e._v(" "),r("li",[e._v("Runtime + Compiler template -> render -> vdom -> 真实dom")])]),e._v(" "),r("p",[e._v("建议在生产环境环境中使用runtime-only。")]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[r("p",[e._v("vue的组件中data和props在不同的配置中，为什么都可以通过this.xxx来访问")])]),e._v(" "),r("li",[r("p",[e._v("hash路由和history路由的主要区别是什么？")])])]),e._v(" "),r("p",[e._v("["),r("a",{attrs:{href:"https://artadmire.github.io/blogs/vue/vue-router-base.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue-router"),r("OutboundLink")],1)]),e._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[r("p",[e._v("pushState不会触发popstate 需要手动触发，在pushState事件中增加代码，浏览器的就前进后退按钮和api会触发popstate")])]),e._v(" "),r("li",[r("p",[e._v("pushState和replaceState兼容性？")])])]),e._v(" "),r("p",[e._v("在IE10以下的浏览器中不兼容\n6. vue 动态组件和异步组件")])])}),[],!1,null,null,null);t.default=n.exports}}]);